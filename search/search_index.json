{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tslib","text":"<p>A correct and consistent API for dealing with leads, lags, differences, and filling in gaps in time-series and panel data. Available in Pandas and PySpark (via pandas-on-Spark).</p> <p>In Pandas, importing <code>tslib</code> grants access to the <code>.ts</code> accessor, allowing for idiomatic creation of lags, leads, and differences with time series and panel data. </p> <p>All Pandas functionality works equally with pandas-on-Spark DataFrames.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>tslib</code> is not currently on PyPI. Install from GitHub with:</p> <p><code>pip install tslib@git+https://github.com/jacgoldsm/tslib</code></p>"},{"location":"#using-with-pyspark","title":"Using with PySpark","text":"<p>To use with the normal PySpark DataFrames, sandwich your <code>tslib</code> code as follows:</p> <pre><code>my_pandas_on_spark = my_spark_df.pandas_api()\n# Use `tslib` Pandas APIs as normal here\nmy_new_spark_df = my_pandas_on_spark.to_spark()\n</code></pre>"},{"location":"#getting-startedtime-series-data","title":"Getting Started\u2014Time-Series Data","text":"<pre><code>import pandas as pd\nfrom tslib.pandas_api import TimeOpts\n\n# Define our Data Frame. `tslib` works with dates stored as numbers or as Pandas dates.\ncookies = pd.DataFrame(\n    {\n        \"year\": [2000, 2001, 2002, 2003, 2008],\n        \"favorite\": [\n            \"Chocolate Chip\",\n            \"Chocolate Chip\",\n            \"Oatmeal Raisin\",\n            \"Sugar\",\n            \"M&amp;M\",\n        ],\n        \"n\": [10, 20, 15, 12, 40],\n    }\n)\nprint(cookies)\n    year       favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n# Define our time series arguments. \n# Set the time-series column, frequency, and start of the time-series.\ncookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n# define our time-series DataFrame\ncookies_ts = cookies.ts(cookies_args)\n# create a DataFrame with all the gaps in the time-series filled in\nprint(cookies_ts.tsfill())\n    year       favorite     n\n0  1999             NaN  &lt;NA&gt;\n1  2000  Chocolate Chip    10\n2  2001  Chocolate Chip    20\n3  2002  Oatmeal Raisin    15\n4  2003           Sugar    12\n5  2004             NaN  &lt;NA&gt;\n6  2005             NaN  &lt;NA&gt;\n7  2006             NaN  &lt;NA&gt;\n8  2007             NaN  &lt;NA&gt;\n9  2008             M&amp;M    40\n# create a DataFrame with the lagged value of `favorite`. \n# Note that lag respects gaps in the data,\n# so year 2008 has no lag since there's no value for 2007\nprint(cookies_ts.with_lag(\"previous_favorite\",column=\"favorite\"))\n    year       favorite   n previous_favorite\n0  2000  Chocolate Chip  10               NaN\n1  2001  Chocolate Chip  20    Chocolate Chip\n2  2002  Oatmeal Raisin  15    Chocolate Chip\n3  2003           Sugar  12    Oatmeal Raisin\n4  2008             M&amp;M  40               NaN\n# the same, but with a lead\nprint(cookies_ts.with_lead(\"next_favorite\",column=\"favorite\"))\n   year        favorite   n   next_favorite\n0  2000  Chocolate Chip  10  Chocolate Chip\n1  2001  Chocolate Chip  20  Oatmeal Raisin\n2  2002  Oatmeal Raisin  15           Sugar\n3  2003           Sugar  12             NaN\n4  2008             M&amp;M  40             NaN\n# the same, but with differencing\nprint(cookies_ts.with_difference(\"change_in_panelists\",column=\"n\"))\n    year       favorite   n  change_in_panelists\n0  2000  Chocolate Chip  10                  NaN\n1  2001  Chocolate Chip  20                 10.0\n2  2002  Oatmeal Raisin  15                 -5.0\n3  2003           Sugar  12                 -3.0\n4  2008             M&amp;M  40                  NaN\n</code></pre>"},{"location":"#getting-started-panel-data","title":"Getting Started: Panel Data","text":"<pre><code>import pandas as pd\nfrom tslib.pandas_api import TimeOpts\n\n# Define our Data Frame. `tslib` works with dates stored as numbers or as Pandas dates.\ndates = [\n    \"2000-01-01\",\n    \"2000-01-01\",\n    \"2000-01-01\",\n    \"2000-02-01\",\n    \"2000-02-01\",\n    \"2000-02-01\",\n    \"2000-04-01\",\n    \"2000-04-01\",\n    \"2000-05-01\",\n    \"2000-05-01\",\n    \"2000-09-01\",\n    \"2000-09-01\",\n    \"2000-09-01\",\n]\n\npanel = pd.DataFrame(\n    {\n        \"id\": [1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 1, 2, 3],\n        \"date\": [pd.to_datetime(date) for date in dates],\n        \"sex\": [\"m\", \"f\", \"f\", \"m\", \"f\", \"f\", \"m\", \"f\", \"m\", \"f\", \"m\", \"f\", \"f\"],\n        \"credit_score\": [\n            750,\n            820,\n            640,\n            760,\n            810,\n            670,\n            740,\n            840,\n            745,\n            620,\n            780,\n            800,\n            630,\n        ],\n    }\n)\nprint(panel)\n    id       date sex  credit_score\n0    1 2000-01-01   m           750\n1    2 2000-01-01   f           820\n2    3 2000-01-01   f           640\n3    1 2000-02-01   m           760\n4    2 2000-02-01   f           810\n5    3 2000-02-01   f           670\n6    1 2000-04-01   m           740\n7    2 2000-04-01   f           840\n8    1 2000-05-01   m           745\n9    3 2000-05-01   f           620\n10   1 2000-09-01   m           780\n11   2 2000-09-01   f           800\n12   3 2000-09-01   f           630\n# define our Time-Series options\npanel_args = TimeOpts(\n    ts_column=\"date\",\n    panel_column=panel[\"id\"],\n    start=\"1999-12-01\",\n    end=\"2000-10-01\",\n    freq=\"1m\",\n)\n\n# set up our time-series DataFrame\npanel_ts = panel.ts(panel_args)\n\n# fill in our complete panel\nprint(panel_ts.tsfill())\n    id       date  sex  credit_score\n0    1 1999-12-01  NaN          &lt;NA&gt;\n1    1 2000-01-01    m           750\n2    1 2000-02-01    m           760\n3    1 2000-03-01  NaN          &lt;NA&gt;\n4    1 2000-04-01    m           740\n5    1 2000-05-01    m           745\n6    1 2000-06-01  NaN          &lt;NA&gt;\n7    1 2000-07-01  NaN          &lt;NA&gt;\n8    1 2000-08-01  NaN          &lt;NA&gt;\n9    1 2000-09-01    m           780\n10   1 2000-10-01  NaN          &lt;NA&gt;\n11   2 1999-12-01  NaN          &lt;NA&gt;\n12   2 2000-01-01    f           820\n13   2 2000-02-01    f           810\n14   2 2000-03-01  NaN          &lt;NA&gt;\n15   2 2000-04-01    f           840\n16   2 2000-05-01  NaN          &lt;NA&gt;\n17   2 2000-06-01  NaN          &lt;NA&gt;\n18   2 2000-07-01  NaN          &lt;NA&gt;\n19   2 2000-08-01  NaN          &lt;NA&gt;\n20   2 2000-09-01    f           800\n21   2 2000-10-01  NaN          &lt;NA&gt;\n22   3 1999-12-01  NaN          &lt;NA&gt;\n23   3 2000-01-01    f           640\n24   3 2000-02-01    f           670\n25   3 2000-03-01  NaN          &lt;NA&gt;\n26   3 2000-04-01  NaN          &lt;NA&gt;\n27   3 2000-05-01    f           620\n28   3 2000-06-01  NaN          &lt;NA&gt;\n29   3 2000-07-01  NaN          &lt;NA&gt;\n30   3 2000-08-01  NaN          &lt;NA&gt;\n31   3 2000-09-01    f           630\n32   3 2000-10-01  NaN          &lt;NA&gt;\n# create our lagged data with lag of 2, with gaps preserved\nprint(panel_ts.with_lag(\"lag_credit\",column=\"credit_score\",back=2))\n    id       date sex  credit_score  lag_credit\n0    1 2000-01-01   m           750        &lt;NA&gt;\n1    2 2000-01-01   f           820        &lt;NA&gt;\n2    3 2000-01-01   f           640        &lt;NA&gt;\n3    1 2000-02-01   m           760        &lt;NA&gt;\n4    2 2000-02-01   f           810        &lt;NA&gt;\n5    3 2000-02-01   f           670        &lt;NA&gt;\n6    1 2000-04-01   m           740         760\n7    2 2000-04-01   f           840         810\n8    1 2000-05-01   m           745        &lt;NA&gt;\n9    3 2000-05-01   f           620        &lt;NA&gt;\n10   1 2000-09-01   m           780        &lt;NA&gt;\n11   2 2000-09-01   f           800        &lt;NA&gt;\n12   3 2000-09-01   f           630        &lt;NA&gt;\n# the same, but with a lead\nprint(panel_ts.with_lead(\"lag_credit\",column=\"credit_score\",forward=2))\n    id       date sex  credit_score  lead_credit\n0    1 2000-01-01   m           750         &lt;NA&gt;\n1    2 2000-01-01   f           820         &lt;NA&gt;\n2    3 2000-01-01   f           640         &lt;NA&gt;\n3    1 2000-02-01   m           760          740\n4    2 2000-02-01   f           810          840\n5    3 2000-02-01   f           670         &lt;NA&gt;\n6    1 2000-04-01   m           740         &lt;NA&gt;\n7    2 2000-04-01   f           840         &lt;NA&gt;\n8    1 2000-05-01   m           745         &lt;NA&gt;\n9    3 2000-05-01   f           620         &lt;NA&gt;\n10   1 2000-09-01   m           780         &lt;NA&gt;\n11   2 2000-09-01   f           800         &lt;NA&gt;\n12   3 2000-09-01   f           630         &lt;NA&gt;\n# the same, but with differencing\nprint(panel_ts.with_difference(name=\"credit_change\",column=\"credit_score\",back=2))\n    id       date sex  credit_score  credit_change\n0    1 2000-01-01   m           750           &lt;NA&gt;\n1    2 2000-01-01   f           820           &lt;NA&gt;\n2    3 2000-01-01   f           640           &lt;NA&gt;\n3    1 2000-02-01   m           760           &lt;NA&gt;\n4    2 2000-02-01   f           810           &lt;NA&gt;\n5    3 2000-02-01   f           670           &lt;NA&gt;\n6    1 2000-04-01   m           740            -20\n7    2 2000-04-01   f           840             30\n8    1 2000-05-01   m           745           &lt;NA&gt;\n9    3 2000-05-01   f           620           &lt;NA&gt;\n10   1 2000-09-01   m           780           &lt;NA&gt;\n11   2 2000-09-01   f           800           &lt;NA&gt;\n12   3 2000-09-01   f           630           &lt;NA&gt;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Before making a pull request, run the tests to ensure that none of them are broken. You can do  this with the following code: <pre><code>python3 -m pip install pytest\npython3 -m pytest\n</code></pre></p>"},{"location":"AUTHORS/","title":"Authors","text":"<ul> <li>Jacob Goldsmith</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unrealeased","title":"Unrealeased","text":"<ul> <li>...</li> </ul>"},{"location":"api/pandas/","title":"Pandas","text":""},{"location":"api/pandas/#tslib.pandas_api.TSAccessor","title":"<code>TSAccessor</code>","text":"Source code in <code>tslib/pandas_api.py</code> <pre><code>@pyspark_register_dataframe_accessor(\"ts\")\n@pd.api.extensions.register_dataframe_accessor(\"ts\")\nclass TSAccessor:\n    def __init__(self, obj: pd.DataFrame | ps.DataFrame):\n        try:\n            import pyspark.pandas as ps\n\n            if isinstance(obj, ps.DataFrame):\n                self._engine = ps\n            else:\n                self._engine = pd\n        except ImportError:\n            self._engine = pd\n\n        self._obj = obj\n\n    def __call__(self, opts: TimeOpts | dict) -&gt; TSAccessor:\n        self._opts = opts\n        return self\n\n    def tsset(\n        self,\n        ts_args: TimeOpts | dict,\n    ) -&gt; TimeDict:\n        data = self._obj.copy()\n        ts_column, panel_column, freq, start, end = TimeOpts._extract_opts(ts_args)\n        out_dict = TimeDict()\n        if isinstance(ts_column, (str, bytes)):\n            ts_column_name = ts_column\n            ts_column = self._obj[ts_column]\n            if len(ts_column) &lt; 2:\n                raise ValueError(\"A time series needs at least two records.\")\n        else:\n            ts_column_name: str = (\n                str(ts_column.name) if ts_column.name is not None else \"time_series\"\n            )\n        out_dict.ts_column_name = ts_column_name\n        if not _is_acceptable_type(ts_column):\n            raise Exception(f\"{ts_column.dtype} not an acceptable time-series type\")\n        if len(ts_column.index) != ts_column.nunique() and panel_column is None:\n            raise Exception(\"Time-series column cannot contain duplicates\")\n        if _is_numeric(ts_column) and not _is_numeric_scalar(freq):\n            raise Exception(\n                \"For a numeric time-series variable\" \"Frequency must be a number.\"\n            )\n        data.index = self._engine.RangeIndex(start=0,stop=len(data.index))\n        is_date = _is_date(ts_column)\n        if is_date:\n            out_dict.freq = pd.tseries.frequencies.to_offset(freq)  # type: ignore\n            assert not isinstance(start, (int, float))\n            assert not isinstance(end, (int, float))\n        else:\n            assert isinstance(freq, (int, float))\n            out_dict.freq = freq\n\n        if start is not None:\n            if is_date:\n                start = pd.to_datetime(start)\n        else:\n            start = ts_column.min()\n\n        if end is not None:\n            if is_date:\n                end = pd.to_datetime(end)\n        else:\n            end = ts_column.max()\n\n        if is_date:\n            complete_time_series = self._engine.period_range(\n                start=start, end=end, freq=out_dict.freq\n            ).to_timestamp()  # type: ignore\n        else:\n            # note that `end` should be inclusive whereas RangeIndex is top-exclusive\n            complete_time_series = self._engine.RangeIndex(\n                start=start,stop=end + freq, step=out_dict.freq\n            )\n        if set(ts_column[(ts_column &gt;= start) &amp; (ts_column &lt;= end)]) - set(\n            complete_time_series\n        ):\n            raise Exception(\"Time series structure doesn't match frequency specified.\")\n\n        if panel_column is not None:\n            if isinstance(panel_column, (str, bytes)):\n                panel_column_name = panel_column\n                panel_column = self._obj[panel_column]\n            else:\n                panel_column_name: str | None = (\n                    str(panel_column.name) if panel_column.name is not None else \"panel\"\n                )\n        else:\n            panel_column_name = None\n\n        out_dict.complete_time_series = complete_time_series\n        out_dict.data = data\n        out_dict.start, out_dict.end = start, end\n        out_dict.is_date = is_date\n        out_dict.panel_column_name = panel_column_name\n        out_dict.data.sort_values(ts_column_name, inplace=True)\n        out_dict.engine = self._engine\n        return out_dict\n\n    def tsfill(\n        self,\n        *,\n        fill_value: Any = None,\n        method: str | None = None,\n        sentinel: str | None = None,\n        keep_index: bool = False,\n        avoid_float_casts: bool = True,\n        opts_replacement: TimeOpts | dict | None = None,\n    ) -&gt; pd.DataFrame | ps.DataFrame:\n        \"\"\"\n        Fill in holes in time-series or panel data\n\n        Args:\n            fill_value: Value to fill in NAs passed to `pandas.DataFrame.reindex`\n            method: Method of filling in NAs passed to `pandas.DataFrame.reindex`\n            sentinel: If not None, the name of a column indicating if a row was\n                present in the original data (True) or was filled in by `tsfill`\n                (False)\n            keep_index: If True, the index of the data returned will be the index of\n                the original data with null values for filled-in observations\n            avoid_float_casts: Use Pandas nullable dtypes to avoid casting integer columns\n                to float when NAs are filled in.\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing TimeOpts arguments from `ts()`\n\n\n        Returns:\n            Pandas DataFrame or pandas-on-Spark DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n            &gt;&gt;&gt; cookies_full\n               year        favorite     n\n            0  1999             NaN  &lt;NA&gt;\n            1  2000  Chocolate Chip    10\n            2  2001  Chocolate Chip    20\n            3  2002  Oatmeal Raisin    15\n            4  2003           Sugar    12\n            5  2004             NaN  &lt;NA&gt;\n            6  2005             NaN  &lt;NA&gt;\n            7  2006             NaN  &lt;NA&gt;\n            8  2007             NaN  &lt;NA&gt;\n            9  2008             M&amp;M    40\n\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        is_panel = TimeOpts._extract_opt(ts_args, \"panel_column\") is not None\n        ts = self.tsset(ts_args=ts_args)\n        assert ts.data is not None\n        out = ts.data.copy()\n        if sentinel is not None:\n            sentinel = str(sentinel)\n            out[sentinel] = True\n        if keep_index:\n            out[\"__index__\"] = out.index\n        if avoid_float_casts:\n            # prevent ints from being turned into floats because of NAs\n            out = out.convert_dtypes(\n                convert_string=False, infer_objects=False, convert_floating=False  # type: ignore\n            )\n\n        assert ts.ts_column_name is not None\n        if not is_panel:\n            assert isinstance(ts.complete_time_series, Iterable)\n            out.index = out[ts.ts_column_name]  # type: ignore\n            out = out.reindex(\n                ts.complete_time_series, method=method, fill_value=fill_value\n            )\n            out[ts.ts_column_name] = ts.complete_time_series\n\n        else:\n            assert ts.panel_column_name is not None\n            out.index = out[ts.ts_column_name]  # type: ignore\n            out_grouped = out.groupby(ts.panel_column_name)\n            new_groups: list[None | pd.DataFrame] = [\n                None for _ in range(len(out_grouped))\n            ]\n            for i, (key, _) in zip(range(len(out_grouped)), out_grouped.groups.items()):\n                subset = out.loc[out[ts.panel_column_name] == key]\n                new_groups[i] = subset.reindex(\n                    ts.complete_time_series, method=method, fill_value=fill_value\n                )\n                new_groups[i][ts.ts_column_name] = ts.complete_time_series\n                new_groups[i][ts.panel_column_name] = key\n            out = ts.engine.concat(new_groups, axis=0)  # type: ignore\n        if sentinel is not None:\n            out[sentinel] = out[sentinel].fillna(False)\n        if keep_index:\n            out.index =out[\"__index__\"]\n            out.index.name = None\n            out.drop(\"__index__\", inplace=True, axis=1)\n        else:\n            out.index = ts.engine.RangeIndex(0,len(out.index))\n        return out\n\n    def with_lag(\n        self,\n        col_name: str,\n        column: str | pd.Series,\n        back: int = 1,\n        *,\n        opts_replacement: TimeOpts | dict | None = None,\n    ) -&gt; pd.DataFrame | ps.DataFrame:\n        \"\"\"\n        Add a lag column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the lag column\n            column: Column to take the lag of\n            back: How many records to go back. Negative values are \"leads\"\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing TimeOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame or pandas-on-Spark DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n            &gt;&gt;&gt; cookies_lag\n               year        favorite   n previous_favorite\n            0  2000  Chocolate Chip  10               NaN\n            1  2001  Chocolate Chip  20    Chocolate Chip\n            2  2002  Oatmeal Raisin  15    Chocolate Chip\n            3  2003           Sugar  12    Oatmeal Raisin\n            4  2008             M&amp;M  40               NaN\n\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        ts = self.tsset(ts_args=ts_args)\n        assert ts.data is not None\n        assert ts.freq is not None\n        if isinstance(column, str):\n            column_string: str = column\n            column = ts.data[column]\n        else:\n            column_string: str = column.name\n\n        if ts.panel_column_name is None:\n            if ts.is_date:\n                # pessimisation: we can't reliably predict the next element of the series\n                # if the column is a date, so we have to use the \"complete\" time series.\n                # Thus, tsfill the data and then use the \"shift\"-based lag method.\n                # Then filter to the original series.\n                out = ts.data.ts(ts_args).tsfill(\n                    sentinel=\"__sentinel__\", keep_index=True\n                )\n                out[col_name] = out[column_string].shift(back)\n                out = out[out[\"__sentinel__\"]]\n                out.drop([\"__sentinel__\"], inplace=True, axis=1)\n            else:\n                assert ts.ts_column_name is not None\n                lagged_col = ts.data[ts.ts_column_name] + (ts.freq * back)  # type: ignore\n                new = ts.engine.DataFrame(\n                    {ts.ts_column_name: lagged_col, col_name: ts.data[column_string]}\n                )\n                out = ts.data.merge(new, on=ts.ts_column_name, how=\"left\")\n        else:\n            if ts.is_date:\n                out = ts.data.ts(ts_args).tsfill(\n                    sentinel=\"__sentinel__\", keep_index=True\n                )\n                out[col_name] = out.groupby(ts.panel_column_name)[column_string].shift(\n                    back\n                )\n                out = out[out[\"__sentinel__\"]]\n                out.drop([\"__sentinel__\"], inplace=True, axis=1)\n            else:\n                assert ts.ts_column_name is not None\n                lagged_col = ts.data[ts.ts_column_name] + (ts.freq * back)  # type: ignore\n                new = ts.engine.DataFrame(\n                    {\n                        ts.ts_column_name: lagged_col,\n                        col_name: ts.data[column_string],\n                        ts.panel_column_name: ts.data[ts.panel_column_name],\n                    }\n                )\n                out = ts.data.merge(\n                    new, on=[ts.ts_column_name, ts.panel_column_name], how=\"left\"\n                )\n\n        out.sort_index(inplace=True)\n        return out\n\n    def with_lead(\n        self,\n        col_name: str,\n        column: pd.Series | ps.Series | str,\n        forward: int | None = 1,\n        opts_replacement: TimeOpts | dict | None = None,\n    ) -&gt; pd.DataFrame | ps.DataFrame:\n        \"\"\"\n        Add a lead column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the lead column\n            column: Column to take the lead of\n            forward: How many records to go forward. Negative values are \"lags\"\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing TimeOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame or pandas-on-Spark DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n            &gt;&gt;&gt; cookies_lead\n               year        favorite   n   next_favorite\n            0  2000  Chocolate Chip  10  Chocolate Chip\n            1  2001  Chocolate Chip  20  Oatmeal Raisin\n            2  2002  Oatmeal Raisin  15           Sugar\n            3  2003           Sugar  12             NaN\n            4  2008             M&amp;M  40             NaN\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        return self.with_lag(\n            col_name, column, back=-1 * forward, opts_replacement=ts_args\n        )\n\n    def with_difference(\n        self,\n        col_name: str,\n        column: str | pd.Series,\n        back: int | None = 1,\n        *,\n        opts_replacement: TimeOpts | dict | None = None,\n    ) -&gt; pd.DataFrame | ps.DataFrame:\n        \"\"\"\n        Add a difference column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the difference column\n            column: Column to take the difference of\n            back: How many records to go back to compute difference.\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing TimeOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame or pandas-on-Spark DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n            &gt;&gt;&gt; cookies_diff\n               year        favorite   n  change_in_panelists\n            0  2000  Chocolate Chip  10                  NaN\n            1  2001  Chocolate Chip  20                 10.0\n            2  2002  Oatmeal Raisin  15                 -5.0\n            3  2003           Sugar  12                 -3.0\n            4  2008             M&amp;M  40                  NaN\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        lag = self.with_lag(\n            \"__difference_dummy__\", column, back, opts_replacement=ts_args\n        )[\"__difference_dummy__\"]\n        curr = self._obj[column]\n        out = self._obj.copy()\n        out[col_name] = curr - lag\n        return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.tsfill","title":"<code>tsfill(*, fill_value=None, method=None, sentinel=None, keep_index=False, avoid_float_casts=True, opts_replacement=None)</code>","text":"<p>Fill in holes in time-series or panel data</p> <p>Parameters:</p> Name Type Description Default <code>fill_value</code> <code>Any</code> <p>Value to fill in NAs passed to <code>pandas.DataFrame.reindex</code></p> <code>None</code> <code>method</code> <code>str | None</code> <p>Method of filling in NAs passed to <code>pandas.DataFrame.reindex</code></p> <code>None</code> <code>sentinel</code> <code>str | None</code> <p>If not None, the name of a column indicating if a row was present in the original data (True) or was filled in by <code>tsfill</code> (False)</p> <code>None</code> <code>keep_index</code> <code>bool</code> <p>If True, the index of the data returned will be the index of the original data with null values for filled-in observations</p> <code>False</code> <code>avoid_float_casts</code> <code>bool</code> <p>Use Pandas nullable dtypes to avoid casting integer columns to float when NAs are filled in.</p> <code>True</code> <code>opts_replacement</code> <code>TimeOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing TimeOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame | DataFrame</code> <p>Pandas DataFrame or pandas-on-Spark DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n&gt;&gt;&gt; cookies_full\n   year        favorite     n\n0  1999             NaN  &lt;NA&gt;\n1  2000  Chocolate Chip    10\n2  2001  Chocolate Chip    20\n3  2002  Oatmeal Raisin    15\n4  2003           Sugar    12\n5  2004             NaN  &lt;NA&gt;\n6  2005             NaN  &lt;NA&gt;\n7  2006             NaN  &lt;NA&gt;\n8  2007             NaN  &lt;NA&gt;\n9  2008             M&amp;M    40\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def tsfill(\n    self,\n    *,\n    fill_value: Any = None,\n    method: str | None = None,\n    sentinel: str | None = None,\n    keep_index: bool = False,\n    avoid_float_casts: bool = True,\n    opts_replacement: TimeOpts | dict | None = None,\n) -&gt; pd.DataFrame | ps.DataFrame:\n    \"\"\"\n    Fill in holes in time-series or panel data\n\n    Args:\n        fill_value: Value to fill in NAs passed to `pandas.DataFrame.reindex`\n        method: Method of filling in NAs passed to `pandas.DataFrame.reindex`\n        sentinel: If not None, the name of a column indicating if a row was\n            present in the original data (True) or was filled in by `tsfill`\n            (False)\n        keep_index: If True, the index of the data returned will be the index of\n            the original data with null values for filled-in observations\n        avoid_float_casts: Use Pandas nullable dtypes to avoid casting integer columns\n            to float when NAs are filled in.\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing TimeOpts arguments from `ts()`\n\n\n    Returns:\n        Pandas DataFrame or pandas-on-Spark DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n        &gt;&gt;&gt; cookies_full\n           year        favorite     n\n        0  1999             NaN  &lt;NA&gt;\n        1  2000  Chocolate Chip    10\n        2  2001  Chocolate Chip    20\n        3  2002  Oatmeal Raisin    15\n        4  2003           Sugar    12\n        5  2004             NaN  &lt;NA&gt;\n        6  2005             NaN  &lt;NA&gt;\n        7  2006             NaN  &lt;NA&gt;\n        8  2007             NaN  &lt;NA&gt;\n        9  2008             M&amp;M    40\n\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    is_panel = TimeOpts._extract_opt(ts_args, \"panel_column\") is not None\n    ts = self.tsset(ts_args=ts_args)\n    assert ts.data is not None\n    out = ts.data.copy()\n    if sentinel is not None:\n        sentinel = str(sentinel)\n        out[sentinel] = True\n    if keep_index:\n        out[\"__index__\"] = out.index\n    if avoid_float_casts:\n        # prevent ints from being turned into floats because of NAs\n        out = out.convert_dtypes(\n            convert_string=False, infer_objects=False, convert_floating=False  # type: ignore\n        )\n\n    assert ts.ts_column_name is not None\n    if not is_panel:\n        assert isinstance(ts.complete_time_series, Iterable)\n        out.index = out[ts.ts_column_name]  # type: ignore\n        out = out.reindex(\n            ts.complete_time_series, method=method, fill_value=fill_value\n        )\n        out[ts.ts_column_name] = ts.complete_time_series\n\n    else:\n        assert ts.panel_column_name is not None\n        out.index = out[ts.ts_column_name]  # type: ignore\n        out_grouped = out.groupby(ts.panel_column_name)\n        new_groups: list[None | pd.DataFrame] = [\n            None for _ in range(len(out_grouped))\n        ]\n        for i, (key, _) in zip(range(len(out_grouped)), out_grouped.groups.items()):\n            subset = out.loc[out[ts.panel_column_name] == key]\n            new_groups[i] = subset.reindex(\n                ts.complete_time_series, method=method, fill_value=fill_value\n            )\n            new_groups[i][ts.ts_column_name] = ts.complete_time_series\n            new_groups[i][ts.panel_column_name] = key\n        out = ts.engine.concat(new_groups, axis=0)  # type: ignore\n    if sentinel is not None:\n        out[sentinel] = out[sentinel].fillna(False)\n    if keep_index:\n        out.index =out[\"__index__\"]\n        out.index.name = None\n        out.drop(\"__index__\", inplace=True, axis=1)\n    else:\n        out.index = ts.engine.RangeIndex(0,len(out.index))\n    return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.with_difference","title":"<code>with_difference(col_name, column, back=1, *, opts_replacement=None)</code>","text":"<p>Add a difference column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the difference column</p> required <code>column</code> <code>str | Series</code> <p>Column to take the difference of</p> required <code>back</code> <code>int | None</code> <p>How many records to go back to compute difference.</p> <code>1</code> <code>opts_replacement</code> <code>TimeOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing TimeOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame | DataFrame</code> <p>Pandas DataFrame or pandas-on-Spark DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n&gt;&gt;&gt; cookies_diff\n   year        favorite   n  change_in_panelists\n0  2000  Chocolate Chip  10                  NaN\n1  2001  Chocolate Chip  20                 10.0\n2  2002  Oatmeal Raisin  15                 -5.0\n3  2003           Sugar  12                 -3.0\n4  2008             M&amp;M  40                  NaN\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def with_difference(\n    self,\n    col_name: str,\n    column: str | pd.Series,\n    back: int | None = 1,\n    *,\n    opts_replacement: TimeOpts | dict | None = None,\n) -&gt; pd.DataFrame | ps.DataFrame:\n    \"\"\"\n    Add a difference column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the difference column\n        column: Column to take the difference of\n        back: How many records to go back to compute difference.\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing TimeOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame or pandas-on-Spark DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n        &gt;&gt;&gt; cookies_diff\n           year        favorite   n  change_in_panelists\n        0  2000  Chocolate Chip  10                  NaN\n        1  2001  Chocolate Chip  20                 10.0\n        2  2002  Oatmeal Raisin  15                 -5.0\n        3  2003           Sugar  12                 -3.0\n        4  2008             M&amp;M  40                  NaN\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    lag = self.with_lag(\n        \"__difference_dummy__\", column, back, opts_replacement=ts_args\n    )[\"__difference_dummy__\"]\n    curr = self._obj[column]\n    out = self._obj.copy()\n    out[col_name] = curr - lag\n    return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.with_lag","title":"<code>with_lag(col_name, column, back=1, *, opts_replacement=None)</code>","text":"<p>Add a lag column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the lag column</p> required <code>column</code> <code>str | Series</code> <p>Column to take the lag of</p> required <code>back</code> <code>int</code> <p>How many records to go back. Negative values are \"leads\"</p> <code>1</code> <code>opts_replacement</code> <code>TimeOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing TimeOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame | DataFrame</code> <p>Pandas DataFrame or pandas-on-Spark DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n&gt;&gt;&gt; cookies_lag\n   year        favorite   n previous_favorite\n0  2000  Chocolate Chip  10               NaN\n1  2001  Chocolate Chip  20    Chocolate Chip\n2  2002  Oatmeal Raisin  15    Chocolate Chip\n3  2003           Sugar  12    Oatmeal Raisin\n4  2008             M&amp;M  40               NaN\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def with_lag(\n    self,\n    col_name: str,\n    column: str | pd.Series,\n    back: int = 1,\n    *,\n    opts_replacement: TimeOpts | dict | None = None,\n) -&gt; pd.DataFrame | ps.DataFrame:\n    \"\"\"\n    Add a lag column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the lag column\n        column: Column to take the lag of\n        back: How many records to go back. Negative values are \"leads\"\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing TimeOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame or pandas-on-Spark DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n        &gt;&gt;&gt; cookies_lag\n           year        favorite   n previous_favorite\n        0  2000  Chocolate Chip  10               NaN\n        1  2001  Chocolate Chip  20    Chocolate Chip\n        2  2002  Oatmeal Raisin  15    Chocolate Chip\n        3  2003           Sugar  12    Oatmeal Raisin\n        4  2008             M&amp;M  40               NaN\n\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    ts = self.tsset(ts_args=ts_args)\n    assert ts.data is not None\n    assert ts.freq is not None\n    if isinstance(column, str):\n        column_string: str = column\n        column = ts.data[column]\n    else:\n        column_string: str = column.name\n\n    if ts.panel_column_name is None:\n        if ts.is_date:\n            # pessimisation: we can't reliably predict the next element of the series\n            # if the column is a date, so we have to use the \"complete\" time series.\n            # Thus, tsfill the data and then use the \"shift\"-based lag method.\n            # Then filter to the original series.\n            out = ts.data.ts(ts_args).tsfill(\n                sentinel=\"__sentinel__\", keep_index=True\n            )\n            out[col_name] = out[column_string].shift(back)\n            out = out[out[\"__sentinel__\"]]\n            out.drop([\"__sentinel__\"], inplace=True, axis=1)\n        else:\n            assert ts.ts_column_name is not None\n            lagged_col = ts.data[ts.ts_column_name] + (ts.freq * back)  # type: ignore\n            new = ts.engine.DataFrame(\n                {ts.ts_column_name: lagged_col, col_name: ts.data[column_string]}\n            )\n            out = ts.data.merge(new, on=ts.ts_column_name, how=\"left\")\n    else:\n        if ts.is_date:\n            out = ts.data.ts(ts_args).tsfill(\n                sentinel=\"__sentinel__\", keep_index=True\n            )\n            out[col_name] = out.groupby(ts.panel_column_name)[column_string].shift(\n                back\n            )\n            out = out[out[\"__sentinel__\"]]\n            out.drop([\"__sentinel__\"], inplace=True, axis=1)\n        else:\n            assert ts.ts_column_name is not None\n            lagged_col = ts.data[ts.ts_column_name] + (ts.freq * back)  # type: ignore\n            new = ts.engine.DataFrame(\n                {\n                    ts.ts_column_name: lagged_col,\n                    col_name: ts.data[column_string],\n                    ts.panel_column_name: ts.data[ts.panel_column_name],\n                }\n            )\n            out = ts.data.merge(\n                new, on=[ts.ts_column_name, ts.panel_column_name], how=\"left\"\n            )\n\n    out.sort_index(inplace=True)\n    return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.with_lead","title":"<code>with_lead(col_name, column, forward=1, opts_replacement=None)</code>","text":"<p>Add a lead column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the lead column</p> required <code>column</code> <code>Series | Series | str</code> <p>Column to take the lead of</p> required <code>forward</code> <code>int | None</code> <p>How many records to go forward. Negative values are \"lags\"</p> <code>1</code> <code>opts_replacement</code> <code>TimeOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing TimeOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame | DataFrame</code> <p>Pandas DataFrame or pandas-on-Spark DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n&gt;&gt;&gt; cookies_lead\n   year        favorite   n   next_favorite\n0  2000  Chocolate Chip  10  Chocolate Chip\n1  2001  Chocolate Chip  20  Oatmeal Raisin\n2  2002  Oatmeal Raisin  15           Sugar\n3  2003           Sugar  12             NaN\n4  2008             M&amp;M  40             NaN\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def with_lead(\n    self,\n    col_name: str,\n    column: pd.Series | ps.Series | str,\n    forward: int | None = 1,\n    opts_replacement: TimeOpts | dict | None = None,\n) -&gt; pd.DataFrame | ps.DataFrame:\n    \"\"\"\n    Add a lead column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the lead column\n        column: Column to take the lead of\n        forward: How many records to go forward. Negative values are \"lags\"\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing TimeOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame or pandas-on-Spark DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import TimeOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n        &gt;&gt;&gt; cookies_lead\n           year        favorite   n   next_favorite\n        0  2000  Chocolate Chip  10  Chocolate Chip\n        1  2001  Chocolate Chip  20  Oatmeal Raisin\n        2  2002  Oatmeal Raisin  15           Sugar\n        3  2003           Sugar  12             NaN\n        4  2008             M&amp;M  40             NaN\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    return self.with_lag(\n        col_name, column, back=-1 * forward, opts_replacement=ts_args\n    )\n</code></pre>"}]}