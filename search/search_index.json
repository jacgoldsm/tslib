{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tslib","text":"<p>A correct and consistent API for dealing with leads, lags, differences, and filling in gaps in time-series and panel data. Available in Pandas and PySpark.</p> <p>In Pandas and PySpark, importing <code>tslib</code> grants access to the <code>.ts</code> accessor, allowing for idiomatic creation of lags, leads, and differences with time series and panel data. </p> <p>See complete documentation here.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>tslib</code> is not currently on PyPI. Install from GitHub with:</p> <p><code>pip install tslib@git+https://github.com/jacgoldsm/tslib</code></p>"},{"location":"#getting-startedtime-series-data","title":"Getting Started\u2014Time-Series Data","text":"<pre><code>import pandas as pd\nfrom tslib.pandas_api import TimeOpts\n\n# Define our Data Frame. `tslib` works with dates stored as numbers or as Pandas dates.\ncookies = pd.DataFrame(\n    {\n        \"year\": [2000, 2001, 2002, 2003, 2008],\n        \"favorite\": [\n            \"Chocolate Chip\",\n            \"Chocolate Chip\",\n            \"Oatmeal Raisin\",\n            \"Sugar\",\n            \"M&amp;M\",\n        ],\n        \"n\": [10, 20, 15, 12, 40],\n    }\n)\nprint(cookies)\n    year       favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n# Define our time series arguments. \n# Set the time-series column, frequency, and start of the time-series.\ncookies_args = TimeOpts(ts_column=\"year\", freq=1, start=1999)\n# define our time-series DataFrame\ncookies_ts = cookies.ts(cookies_args)\n# create a DataFrame with all the gaps in the time-series filled in\nprint(cookies_ts.tsfill())\n    year       favorite     n\n0  1999             NaN  &lt;NA&gt;\n1  2000  Chocolate Chip    10\n2  2001  Chocolate Chip    20\n3  2002  Oatmeal Raisin    15\n4  2003           Sugar    12\n5  2004             NaN  &lt;NA&gt;\n6  2005             NaN  &lt;NA&gt;\n7  2006             NaN  &lt;NA&gt;\n8  2007             NaN  &lt;NA&gt;\n9  2008             M&amp;M    40\n# create a DataFrame with the lagged value of `favorite`. \n# Note that lag respects gaps in the data,\n# so year 2008 has no lag since there's no value for 2007\nprint(cookies_ts.with_lag(\"previous_favorite\",column=\"favorite\"))\n    year       favorite   n previous_favorite\n0  2000  Chocolate Chip  10               NaN\n1  2001  Chocolate Chip  20    Chocolate Chip\n2  2002  Oatmeal Raisin  15    Chocolate Chip\n3  2003           Sugar  12    Oatmeal Raisin\n4  2008             M&amp;M  40               NaN\n# the same, but with a lead\nprint(cookies_ts.with_lead(\"next_favorite\",column=\"favorite\"))\n   year        favorite   n   next_favorite\n0  2000  Chocolate Chip  10  Chocolate Chip\n1  2001  Chocolate Chip  20  Oatmeal Raisin\n2  2002  Oatmeal Raisin  15           Sugar\n3  2003           Sugar  12             NaN\n4  2008             M&amp;M  40             NaN\n# the same, but with differencing\nprint(cookies_ts.with_difference(\"change_in_panelists\",column=\"n\"))\n    year       favorite   n  change_in_panelists\n0  2000  Chocolate Chip  10                  NaN\n1  2001  Chocolate Chip  20                 10.0\n2  2002  Oatmeal Raisin  15                 -5.0\n3  2003           Sugar  12                 -3.0\n4  2008             M&amp;M  40                  NaN\n</code></pre>"},{"location":"#getting-started-panel-data","title":"Getting Started: Panel Data","text":"<pre><code>import pandas as pd\nfrom tslib.pandas_api import TimeOpts\n\n# Define our Data Frame. `tslib` works with dates stored as numbers or as Pandas dates.\ndates = [\n    \"2000-01-01\",\n    \"2000-01-01\",\n    \"2000-01-01\",\n    \"2000-02-01\",\n    \"2000-02-01\",\n    \"2000-02-01\",\n    \"2000-04-01\",\n    \"2000-04-01\",\n    \"2000-05-01\",\n    \"2000-05-01\",\n    \"2000-09-01\",\n    \"2000-09-01\",\n    \"2000-09-01\",\n]\n\npanel = pd.DataFrame(\n    {\n        \"id\": [1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 1, 2, 3],\n        \"date\": [pd.to_datetime(date) for date in dates],\n        \"sex\": [\"m\", \"f\", \"f\", \"m\", \"f\", \"f\", \"m\", \"f\", \"m\", \"f\", \"m\", \"f\", \"f\"],\n        \"credit_score\": [\n            750,\n            820,\n            640,\n            760,\n            810,\n            670,\n            740,\n            840,\n            745,\n            620,\n            780,\n            800,\n            630,\n        ],\n    }\n)\nprint(panel)\n    id       date sex  credit_score\n0    1 2000-01-01   m           750\n1    2 2000-01-01   f           820\n2    3 2000-01-01   f           640\n3    1 2000-02-01   m           760\n4    2 2000-02-01   f           810\n5    3 2000-02-01   f           670\n6    1 2000-04-01   m           740\n7    2 2000-04-01   f           840\n8    1 2000-05-01   m           745\n9    3 2000-05-01   f           620\n10   1 2000-09-01   m           780\n11   2 2000-09-01   f           800\n12   3 2000-09-01   f           630\n# define our Time-Series options\npanel_args = TimeOpts(\n    ts_column=\"date\",\n    panel_column=panel[\"id\"],\n    start=\"1999-12-01\",\n    end=\"2000-10-01\",\n    freq=\"1m\",\n)\n\n# set up our time-series DataFrame\npanel_ts = panel.ts(panel_args)\n\n# fill in our complete panel\nprint(panel_ts.tsfill())\n    id       date  sex  credit_score\n0    1 1999-12-01  NaN          &lt;NA&gt;\n1    1 2000-01-01    m           750\n2    1 2000-02-01    m           760\n3    1 2000-03-01  NaN          &lt;NA&gt;\n4    1 2000-04-01    m           740\n5    1 2000-05-01    m           745\n6    1 2000-06-01  NaN          &lt;NA&gt;\n7    1 2000-07-01  NaN          &lt;NA&gt;\n8    1 2000-08-01  NaN          &lt;NA&gt;\n9    1 2000-09-01    m           780\n10   1 2000-10-01  NaN          &lt;NA&gt;\n11   2 1999-12-01  NaN          &lt;NA&gt;\n12   2 2000-01-01    f           820\n13   2 2000-02-01    f           810\n14   2 2000-03-01  NaN          &lt;NA&gt;\n15   2 2000-04-01    f           840\n16   2 2000-05-01  NaN          &lt;NA&gt;\n17   2 2000-06-01  NaN          &lt;NA&gt;\n18   2 2000-07-01  NaN          &lt;NA&gt;\n19   2 2000-08-01  NaN          &lt;NA&gt;\n20   2 2000-09-01    f           800\n21   2 2000-10-01  NaN          &lt;NA&gt;\n22   3 1999-12-01  NaN          &lt;NA&gt;\n23   3 2000-01-01    f           640\n24   3 2000-02-01    f           670\n25   3 2000-03-01  NaN          &lt;NA&gt;\n26   3 2000-04-01  NaN          &lt;NA&gt;\n27   3 2000-05-01    f           620\n28   3 2000-06-01  NaN          &lt;NA&gt;\n29   3 2000-07-01  NaN          &lt;NA&gt;\n30   3 2000-08-01  NaN          &lt;NA&gt;\n31   3 2000-09-01    f           630\n32   3 2000-10-01  NaN          &lt;NA&gt;\n# create our lagged data with lag of 2, with gaps preserved\nprint(panel_ts.with_lag(\"lag_credit\",column=\"credit_score\",back=2))\n    id       date sex  credit_score  lag_credit\n0    1 2000-01-01   m           750        &lt;NA&gt;\n1    2 2000-01-01   f           820        &lt;NA&gt;\n2    3 2000-01-01   f           640        &lt;NA&gt;\n3    1 2000-02-01   m           760        &lt;NA&gt;\n4    2 2000-02-01   f           810        &lt;NA&gt;\n5    3 2000-02-01   f           670        &lt;NA&gt;\n6    1 2000-04-01   m           740         760\n7    2 2000-04-01   f           840         810\n8    1 2000-05-01   m           745        &lt;NA&gt;\n9    3 2000-05-01   f           620        &lt;NA&gt;\n10   1 2000-09-01   m           780        &lt;NA&gt;\n11   2 2000-09-01   f           800        &lt;NA&gt;\n12   3 2000-09-01   f           630        &lt;NA&gt;\n# the same, but with a lead\nprint(panel_ts.with_lead(\"lag_credit\",column=\"credit_score\",forward=2))\n    id       date sex  credit_score  lead_credit\n0    1 2000-01-01   m           750         &lt;NA&gt;\n1    2 2000-01-01   f           820         &lt;NA&gt;\n2    3 2000-01-01   f           640         &lt;NA&gt;\n3    1 2000-02-01   m           760          740\n4    2 2000-02-01   f           810          840\n5    3 2000-02-01   f           670         &lt;NA&gt;\n6    1 2000-04-01   m           740         &lt;NA&gt;\n7    2 2000-04-01   f           840         &lt;NA&gt;\n8    1 2000-05-01   m           745         &lt;NA&gt;\n9    3 2000-05-01   f           620         &lt;NA&gt;\n10   1 2000-09-01   m           780         &lt;NA&gt;\n11   2 2000-09-01   f           800         &lt;NA&gt;\n12   3 2000-09-01   f           630         &lt;NA&gt;\n# the same, but with differencing\nprint(panel_ts.with_difference(name=\"credit_change\",column=\"credit_score\",back=2))\n    id       date sex  credit_score  credit_change\n0    1 2000-01-01   m           750           &lt;NA&gt;\n1    2 2000-01-01   f           820           &lt;NA&gt;\n2    3 2000-01-01   f           640           &lt;NA&gt;\n3    1 2000-02-01   m           760           &lt;NA&gt;\n4    2 2000-02-01   f           810           &lt;NA&gt;\n5    3 2000-02-01   f           670           &lt;NA&gt;\n6    1 2000-04-01   m           740            -20\n7    2 2000-04-01   f           840             30\n8    1 2000-05-01   m           745           &lt;NA&gt;\n9    3 2000-05-01   f           620           &lt;NA&gt;\n10   1 2000-09-01   m           780           &lt;NA&gt;\n11   2 2000-09-01   f           800           &lt;NA&gt;\n12   3 2000-09-01   f           630           &lt;NA&gt;\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Before making a pull request, run the tests to ensure that none of them are broken. You can do  this with the following code: <pre><code>python3 -m pip install pytest\npython3 -m pytest\n</code></pre></p>"},{"location":"#building-the-docs","title":"Building the Docs","text":"<p>To rebuild the docs, run the following</p> <pre><code>python3 -m pip install mkdocs mkdocstrings[python] mkdocs-material\nmkdocs build\n</code></pre> <p>See what it looks like on a local server with <code>mkdocs serve</code>. Once it looks right, deploy with <code>mkdocs gh-deploy</code>.</p> <p>Once it's deployed, delete the site/ repository so it doesn't pollute the main branch.</p>"},{"location":"AUTHORS/","title":"Authors","text":"<ul> <li>Jacob Goldsmith</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unrealeased","title":"Unrealeased","text":"<ul> <li>...</li> </ul>"},{"location":"api/pandas/","title":"Pandas","text":""},{"location":"api/pandas/#tslib.pandas_api.TSAccessor","title":"<code>TSAccessor</code>","text":"Source code in <code>tslib/pandas_api.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"ts\")\nclass TSAccessor:\n    def __init__(self, obj: pd.DataFrame):\n        self._obj = obj\n\n    def __call__(self, opts: PandasOpts | dict) -&gt; TSAccessor:\n        self._opts = opts\n        return self\n\n    def tsset(\n        self,\n        ts_args: PandasOpts | dict,\n    ) -&gt; TimeDict:\n        data = self._obj.copy()\n        ts_column, panel_column, freq, start, end = PandasOpts._extract_opts(ts_args)\n        out_dict = TimeDict()\n        if isinstance(ts_column, (str, bytes)):\n            ts_column_name = ts_column\n            ts_column = self._obj[ts_column]\n            if len(ts_column) &lt; 2:\n                raise ValueError(\"A time series needs at least two records.\")\n        else:\n            ts_column_name: str = (\n                str(ts_column.name) if ts_column.name is not None else \"time_series\"\n            )\n        out_dict.ts_column_name = ts_column_name\n        if not _is_acceptable_type(ts_column):\n            raise Exception(f\"{ts_column.dtype} not an acceptable time-series type\")\n        if len(ts_column.index) != ts_column.nunique() and panel_column is None:\n            raise Exception(\"Time-series column cannot contain duplicates\")\n        if _is_numeric(ts_column) and not _is_numeric_scalar(freq):\n            raise Exception(\n                \"For a numeric time-series variable\" \"Frequency must be a number.\"\n            )\n        data.index = np.arange(len(data.index))  # type: ignore\n        is_date = _is_date(ts_column)\n        if is_date:\n            out_dict.freq = pd.tseries.frequencies.to_offset(freq)  # type: ignore\n        else:\n            out_dict.freq = freq\n\n        if start is not None:\n            if is_date:\n                start = pd.to_datetime(start)\n        else:\n            start = ts_column.min()\n\n        if end is not None:\n            if is_date:\n                end = pd.to_datetime(end)\n        else:\n            end = ts_column.max()\n\n        if is_date:\n            complete_time_series = pd.period_range(\n                start=start, end=end, freq=out_dict.freq\n            ).to_timestamp()  # type: ignore\n        else:\n            # note that `end` should be inclusive whereas np.arange is top-exclusive\n            complete_time_series = np.arange(\n                start=start, stop=end + freq, step=out_dict.freq\n            )\n        if set(ts_column[(ts_column &gt;= start) &amp; (ts_column &lt;= end)]) - set(\n            complete_time_series\n        ):\n            raise Exception(\"Time series structure doesn't match frequency specified.\")\n\n        if panel_column is not None:\n            if isinstance(panel_column, (str, bytes)):\n                panel_column_name = panel_column\n                panel_column = self._obj[panel_column]\n            else:\n                panel_column_name: str | None = (\n                    str(panel_column.name) if panel_column.name is not None else \"panel\"\n                )\n        else:\n            panel_column_name = None\n\n        if is_date:\n            numeric_series = offsets_since_epoch(ts_column, freq)\n            data['__offsets_since_epoch__'] = numeric_series\n\n\n        out_dict.complete_time_series = complete_time_series\n        out_dict.data = data\n        out_dict.start, out_dict.end = start, end\n        out_dict.is_date = is_date\n        out_dict.panel_column_name = panel_column_name\n        out_dict.data.sort_values(ts_column_name, inplace=True)\n        return out_dict\n\n    def tsfill(\n        self,\n        *,\n        method: str | None = None,\n        opts_replacement: PandasOpts | dict | None = None,\n        fill_value: Any = None,\n        sentinel: str | None = None,\n        keep_index: bool = False,\n        avoid_float_casts: bool = True,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Fill in holes in time-series or panel data\n\n        Args:\n            fill_value: Value to fill in NAs passed to `pandas.DataFrame.reindex`\n            sentinel: If not None, the name of a column indicating if a row was\n                present in the original data (True) or was filled in by `tsfill`\n                (False)\n            keep_index: If True, the index of the data returned will be the index of\n                the original data with null values for filled-in observations\n            avoid_float_casts: Use Pandas nullable dtypes to avoid casting integer columns\n                to float when NAs are filled in.\n\n\n        Returns:\n            Pandas DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n            &gt;&gt;&gt; cookies_full\n               year        favorite     n\n            0  1999             NaN  &lt;NA&gt;\n            1  2000  Chocolate Chip    10\n            2  2001  Chocolate Chip    20\n            3  2002  Oatmeal Raisin    15\n            4  2003           Sugar    12\n            5  2004             NaN  &lt;NA&gt;\n            6  2005             NaN  &lt;NA&gt;\n            7  2006             NaN  &lt;NA&gt;\n            8  2007             NaN  &lt;NA&gt;\n            9  2008             M&amp;M    40\n\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        is_panel = PandasOpts._extract_opt(ts_args, \"panel_column\") is not None\n        if not is_panel:\n            ts = self.tsset(ts_args=ts_args)\n        else:\n            ts = self.tsset(ts_args=ts_args)\n        assert ts.data is not None\n        out = ts.data.copy()\n        if sentinel is not None:\n            sentinel = str(sentinel)\n            out[sentinel] = True\n        if keep_index:\n            out['__index__'] = out.index\n        if avoid_float_casts:\n            # prevent ints from being turned into floats because of NAs\n            out = out.convert_dtypes(\n                convert_string=False, infer_objects=False, convert_floating=False  # type: ignore\n            )\n\n        assert ts.ts_column_name is not None\n        if not is_panel:\n            assert isinstance(ts.complete_time_series, Iterable)\n            out.index = out[ts.ts_column_name]  # type: ignore\n            out = out.reindex(\n                ts.complete_time_series, method=method, fill_value=fill_value\n            )\n            out[ts.ts_column_name] = ts.complete_time_series\n\n        else:\n            assert ts.panel_column_name is not None\n            out.index = out[ts.ts_column_name]  # type: ignore\n            out_grouped = out.groupby(ts.panel_column_name)\n            new_groups: list[None | pd.DataFrame] = [\n                None for _ in range(len(out_grouped))\n            ]\n            for i, (key, _) in zip(range(len(out_grouped)), out_grouped.groups.items()):\n                subset = out.loc[out[ts.panel_column_name] == key]\n                new_groups[i] = subset.reindex(\n                    ts.complete_time_series, method=method, fill_value=fill_value\n                )\n                new_groups[i][ts.ts_column_name] = ts.complete_time_series\n                new_groups[i][ts.panel_column_name] = key\n            out = pd.concat(new_groups, axis=0)  # type: ignore\n        if sentinel is not None:\n            out[sentinel] = out[sentinel].fillna(False)\n        if keep_index:\n            out.index = np.array(out['__index__'])\n            out.drop(\"__index__\",inplace=True,axis=1)\n        else:\n            out.index = np.arange(len(out.index))\n        if ts.is_date:\n            return out.drop(\"__offsets_since_epoch__\",axis=1)\n        else:\n            return out\n\n    def with_lag(\n        self,\n        col_name: str,\n        column: str | pd.Series,\n        back: int = 1,\n        *,\n        opts_replacement: PandasOpts | dict | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Add a lag column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the lag column\n            column: Column to take the lag of\n            back: How many records to go back. Negative values are \"leads\"\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing PandasOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n            &gt;&gt;&gt; cookies_lag\n               year        favorite   n previous_favorite\n            0  2000  Chocolate Chip  10               NaN\n            1  2001  Chocolate Chip  20    Chocolate Chip\n            2  2002  Oatmeal Raisin  15    Chocolate Chip\n            3  2003           Sugar  12    Oatmeal Raisin\n            4  2008             M&amp;M  40               NaN\n\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        ts = self.tsset(ts_args=ts_args)\n        assert ts.data is not None\n        assert ts.freq is not None\n        if isinstance(column,str):\n            column_string: str = column\n            column = ts.data[column]\n        else:\n            column_string: str = column.name\n\n        time_col = ts.ts_column_name if not ts.is_date else \"__offsets_since_epoch__\"\n        freq = ts.freq if not ts.is_date else ts.freq.n\n        if ts.panel_column_name is None:\n            assert ts.ts_column_name is not None\n            lagged_col = ts.data[time_col] + (freq * back)  # type: ignore\n            new = pd.DataFrame({time_col: lagged_col, col_name: ts.data[column_string]})\n            out = ts.data.merge(new, on=time_col, how=\"left\")\n        else:\n            assert ts.ts_column_name is not None\n            lagged_col = ts.data[time_col] + (freq * back)  # type: ignore\n            new = pd.DataFrame({time_col: lagged_col, col_name: ts.data[column_string], ts.panel_column_name:ts.data[ts.panel_column_name]})\n            out = ts.data.merge(new, on=[time_col,ts.panel_column_name], how=\"left\")\n\n        out.sort_index(inplace=True)\n        if ts.is_date:\n            return out.drop(\"__offsets_since_epoch__\",axis=1)\n        else:\n            return out\n\n    def with_lead(\n        self,\n        col_name: str,\n        column: pd.Series | str,\n        forward: int | None =1,\n        opts_replacement: PandasOpts | dict | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Add a lead column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the lead column\n            column: Column to take the lead of\n            forward: How many records to go forward. Negative values are \"lags\"\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing PandasOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n            &gt;&gt;&gt; cookies_lead\n               year        favorite   n   next_favorite\n            0  2000  Chocolate Chip  10  Chocolate Chip\n            1  2001  Chocolate Chip  20  Oatmeal Raisin\n            2  2002  Oatmeal Raisin  15           Sugar\n            3  2003           Sugar  12             NaN\n            4  2008             M&amp;M  40             NaN\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        return self.with_lag(col_name, column, back=-1 * forward, opts_replacement=ts_args)\n\n    def with_difference(\n        self,\n        col_name: str,\n        column: str | pd.Series,\n        back: int | None =1,\n        *,\n        opts_replacement: PandasOpts | dict | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Add a difference column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the difference column\n            column: Column to take the difference of\n            back: How many records to go back to compute difference.\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing PandasOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; cookies = pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... )\n            &gt;&gt;&gt; cookies\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n            &gt;&gt;&gt; cookies_diff\n               year        favorite   n  change_in_panelists\n            0  2000  Chocolate Chip  10                  NaN\n            1  2001  Chocolate Chip  20                 10.0\n            2  2002  Oatmeal Raisin  15                 -5.0\n            3  2003           Sugar  12                 -3.0\n            4  2008             M&amp;M  40                  NaN\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        lag = self.with_lag(\n            \"__difference_dummy__\", column, back, opts_replacement=ts_args\n        )[\"__difference_dummy__\"]\n        curr = self._obj[column]\n        out = self._obj.copy()\n        out[col_name] = curr - lag\n        if hasattr(out, \"__offsets_since_epoch__\"):\n            return out.drop(\"__offsets_since_epoch__\",axis=1)\n        else:\n            return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.tsfill","title":"<code>tsfill(*, method=None, opts_replacement=None, fill_value=None, sentinel=None, keep_index=False, avoid_float_casts=True)</code>","text":"<p>Fill in holes in time-series or panel data</p> <p>Parameters:</p> Name Type Description Default <code>fill_value</code> <code>Any</code> <p>Value to fill in NAs passed to <code>pandas.DataFrame.reindex</code></p> <code>None</code> <code>sentinel</code> <code>str | None</code> <p>If not None, the name of a column indicating if a row was present in the original data (True) or was filled in by <code>tsfill</code> (False)</p> <code>None</code> <code>keep_index</code> <code>bool</code> <p>If True, the index of the data returned will be the index of the original data with null values for filled-in observations</p> <code>False</code> <code>avoid_float_casts</code> <code>bool</code> <p>Use Pandas nullable dtypes to avoid casting integer columns to float when NAs are filled in.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n&gt;&gt;&gt; cookies_full\n   year        favorite     n\n0  1999             NaN  &lt;NA&gt;\n1  2000  Chocolate Chip    10\n2  2001  Chocolate Chip    20\n3  2002  Oatmeal Raisin    15\n4  2003           Sugar    12\n5  2004             NaN  &lt;NA&gt;\n6  2005             NaN  &lt;NA&gt;\n7  2006             NaN  &lt;NA&gt;\n8  2007             NaN  &lt;NA&gt;\n9  2008             M&amp;M    40\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def tsfill(\n    self,\n    *,\n    method: str | None = None,\n    opts_replacement: PandasOpts | dict | None = None,\n    fill_value: Any = None,\n    sentinel: str | None = None,\n    keep_index: bool = False,\n    avoid_float_casts: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fill in holes in time-series or panel data\n\n    Args:\n        fill_value: Value to fill in NAs passed to `pandas.DataFrame.reindex`\n        sentinel: If not None, the name of a column indicating if a row was\n            present in the original data (True) or was filled in by `tsfill`\n            (False)\n        keep_index: If True, the index of the data returned will be the index of\n            the original data with null values for filled-in observations\n        avoid_float_casts: Use Pandas nullable dtypes to avoid casting integer columns\n            to float when NAs are filled in.\n\n\n    Returns:\n        Pandas DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n        &gt;&gt;&gt; cookies_full\n           year        favorite     n\n        0  1999             NaN  &lt;NA&gt;\n        1  2000  Chocolate Chip    10\n        2  2001  Chocolate Chip    20\n        3  2002  Oatmeal Raisin    15\n        4  2003           Sugar    12\n        5  2004             NaN  &lt;NA&gt;\n        6  2005             NaN  &lt;NA&gt;\n        7  2006             NaN  &lt;NA&gt;\n        8  2007             NaN  &lt;NA&gt;\n        9  2008             M&amp;M    40\n\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    is_panel = PandasOpts._extract_opt(ts_args, \"panel_column\") is not None\n    if not is_panel:\n        ts = self.tsset(ts_args=ts_args)\n    else:\n        ts = self.tsset(ts_args=ts_args)\n    assert ts.data is not None\n    out = ts.data.copy()\n    if sentinel is not None:\n        sentinel = str(sentinel)\n        out[sentinel] = True\n    if keep_index:\n        out['__index__'] = out.index\n    if avoid_float_casts:\n        # prevent ints from being turned into floats because of NAs\n        out = out.convert_dtypes(\n            convert_string=False, infer_objects=False, convert_floating=False  # type: ignore\n        )\n\n    assert ts.ts_column_name is not None\n    if not is_panel:\n        assert isinstance(ts.complete_time_series, Iterable)\n        out.index = out[ts.ts_column_name]  # type: ignore\n        out = out.reindex(\n            ts.complete_time_series, method=method, fill_value=fill_value\n        )\n        out[ts.ts_column_name] = ts.complete_time_series\n\n    else:\n        assert ts.panel_column_name is not None\n        out.index = out[ts.ts_column_name]  # type: ignore\n        out_grouped = out.groupby(ts.panel_column_name)\n        new_groups: list[None | pd.DataFrame] = [\n            None for _ in range(len(out_grouped))\n        ]\n        for i, (key, _) in zip(range(len(out_grouped)), out_grouped.groups.items()):\n            subset = out.loc[out[ts.panel_column_name] == key]\n            new_groups[i] = subset.reindex(\n                ts.complete_time_series, method=method, fill_value=fill_value\n            )\n            new_groups[i][ts.ts_column_name] = ts.complete_time_series\n            new_groups[i][ts.panel_column_name] = key\n        out = pd.concat(new_groups, axis=0)  # type: ignore\n    if sentinel is not None:\n        out[sentinel] = out[sentinel].fillna(False)\n    if keep_index:\n        out.index = np.array(out['__index__'])\n        out.drop(\"__index__\",inplace=True,axis=1)\n    else:\n        out.index = np.arange(len(out.index))\n    if ts.is_date:\n        return out.drop(\"__offsets_since_epoch__\",axis=1)\n    else:\n        return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.with_difference","title":"<code>with_difference(col_name, column, back=1, *, opts_replacement=None)</code>","text":"<p>Add a difference column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the difference column</p> required <code>column</code> <code>str | Series</code> <p>Column to take the difference of</p> required <code>back</code> <code>int | None</code> <p>How many records to go back to compute difference.</p> <code>1</code> <code>opts_replacement</code> <code>PandasOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing PandasOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n&gt;&gt;&gt; cookies_diff\n   year        favorite   n  change_in_panelists\n0  2000  Chocolate Chip  10                  NaN\n1  2001  Chocolate Chip  20                 10.0\n2  2002  Oatmeal Raisin  15                 -5.0\n3  2003           Sugar  12                 -3.0\n4  2008             M&amp;M  40                  NaN\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def with_difference(\n    self,\n    col_name: str,\n    column: str | pd.Series,\n    back: int | None =1,\n    *,\n    opts_replacement: PandasOpts | dict | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Add a difference column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the difference column\n        column: Column to take the difference of\n        back: How many records to go back to compute difference.\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing PandasOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n        &gt;&gt;&gt; cookies_diff\n           year        favorite   n  change_in_panelists\n        0  2000  Chocolate Chip  10                  NaN\n        1  2001  Chocolate Chip  20                 10.0\n        2  2002  Oatmeal Raisin  15                 -5.0\n        3  2003           Sugar  12                 -3.0\n        4  2008             M&amp;M  40                  NaN\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    lag = self.with_lag(\n        \"__difference_dummy__\", column, back, opts_replacement=ts_args\n    )[\"__difference_dummy__\"]\n    curr = self._obj[column]\n    out = self._obj.copy()\n    out[col_name] = curr - lag\n    if hasattr(out, \"__offsets_since_epoch__\"):\n        return out.drop(\"__offsets_since_epoch__\",axis=1)\n    else:\n        return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.with_lag","title":"<code>with_lag(col_name, column, back=1, *, opts_replacement=None)</code>","text":"<p>Add a lag column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the lag column</p> required <code>column</code> <code>str | Series</code> <p>Column to take the lag of</p> required <code>back</code> <code>int</code> <p>How many records to go back. Negative values are \"leads\"</p> <code>1</code> <code>opts_replacement</code> <code>PandasOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing PandasOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n&gt;&gt;&gt; cookies_lag\n   year        favorite   n previous_favorite\n0  2000  Chocolate Chip  10               NaN\n1  2001  Chocolate Chip  20    Chocolate Chip\n2  2002  Oatmeal Raisin  15    Chocolate Chip\n3  2003           Sugar  12    Oatmeal Raisin\n4  2008             M&amp;M  40               NaN\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def with_lag(\n    self,\n    col_name: str,\n    column: str | pd.Series,\n    back: int = 1,\n    *,\n    opts_replacement: PandasOpts | dict | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Add a lag column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the lag column\n        column: Column to take the lag of\n        back: How many records to go back. Negative values are \"leads\"\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing PandasOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n        &gt;&gt;&gt; cookies_lag\n           year        favorite   n previous_favorite\n        0  2000  Chocolate Chip  10               NaN\n        1  2001  Chocolate Chip  20    Chocolate Chip\n        2  2002  Oatmeal Raisin  15    Chocolate Chip\n        3  2003           Sugar  12    Oatmeal Raisin\n        4  2008             M&amp;M  40               NaN\n\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    ts = self.tsset(ts_args=ts_args)\n    assert ts.data is not None\n    assert ts.freq is not None\n    if isinstance(column,str):\n        column_string: str = column\n        column = ts.data[column]\n    else:\n        column_string: str = column.name\n\n    time_col = ts.ts_column_name if not ts.is_date else \"__offsets_since_epoch__\"\n    freq = ts.freq if not ts.is_date else ts.freq.n\n    if ts.panel_column_name is None:\n        assert ts.ts_column_name is not None\n        lagged_col = ts.data[time_col] + (freq * back)  # type: ignore\n        new = pd.DataFrame({time_col: lagged_col, col_name: ts.data[column_string]})\n        out = ts.data.merge(new, on=time_col, how=\"left\")\n    else:\n        assert ts.ts_column_name is not None\n        lagged_col = ts.data[time_col] + (freq * back)  # type: ignore\n        new = pd.DataFrame({time_col: lagged_col, col_name: ts.data[column_string], ts.panel_column_name:ts.data[ts.panel_column_name]})\n        out = ts.data.merge(new, on=[time_col,ts.panel_column_name], how=\"left\")\n\n    out.sort_index(inplace=True)\n    if ts.is_date:\n        return out.drop(\"__offsets_since_epoch__\",axis=1)\n    else:\n        return out\n</code></pre>"},{"location":"api/pandas/#tslib.pandas_api.TSAccessor.with_lead","title":"<code>with_lead(col_name, column, forward=1, opts_replacement=None)</code>","text":"<p>Add a lead column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the lead column</p> required <code>column</code> <code>Series | str</code> <p>Column to take the lead of</p> required <code>forward</code> <code>int | None</code> <p>How many records to go forward. Negative values are \"lags\"</p> <code>1</code> <code>opts_replacement</code> <code>PandasOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing PandasOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; cookies = pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... )\n&gt;&gt;&gt; cookies\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n&gt;&gt;&gt; cookies_lead\n   year        favorite   n   next_favorite\n0  2000  Chocolate Chip  10  Chocolate Chip\n1  2001  Chocolate Chip  20  Oatmeal Raisin\n2  2002  Oatmeal Raisin  15           Sugar\n3  2003           Sugar  12             NaN\n4  2008             M&amp;M  40             NaN\n</code></pre> Source code in <code>tslib/pandas_api.py</code> <pre><code>def with_lead(\n    self,\n    col_name: str,\n    column: pd.Series | str,\n    forward: int | None =1,\n    opts_replacement: PandasOpts | dict | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Add a lead column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the lead column\n        column: Column to take the lead of\n        forward: How many records to go forward. Negative values are \"lags\"\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing PandasOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pandas_api import PandasOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; cookies = pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... )\n        &gt;&gt;&gt; cookies\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = PandasOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n        &gt;&gt;&gt; cookies_lead\n           year        favorite   n   next_favorite\n        0  2000  Chocolate Chip  10  Chocolate Chip\n        1  2001  Chocolate Chip  20  Oatmeal Raisin\n        2  2002  Oatmeal Raisin  15           Sugar\n        3  2003           Sugar  12             NaN\n        4  2008             M&amp;M  40             NaN\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    return self.with_lag(col_name, column, back=-1 * forward, opts_replacement=ts_args)\n</code></pre>"},{"location":"api/pyspark/","title":"PySpark","text":""},{"location":"api/pyspark/#tslib.pyspark_api.TSAccessor","title":"<code>TSAccessor</code>","text":"Source code in <code>tslib/pyspark_api.py</code> <pre><code>class TSAccessor:\n    def __init__(self, obj: pyspark.sql.dataframe.DataFrame):\n        self._obj = obj\n\n    def __call__(self, opts):\n        self._opts = opts\n        return self\n\n    def tsset(self, ts_args: SparkOpts | dict):\n        out_dict = _TimeDict()\n        ts_column, panel_column, freq, start, end = SparkOpts._extract_opts(ts_args)\n        if not _is_acceptable_type(self._obj, ts_column):\n            raise Exception(f\"{ts_column.dtype} not an acceptable time-series type\")\n        if _is_numeric(self._obj, ts_column) and not _is_numeric_scalar(freq):\n            raise Exception(\n                \"For a numeric time-series variable\" \"Frequency must be a number.\"\n            )\n        is_date = _is_date(self._obj,ts_column)\n        if is_date:\n            out_dict.freq = pd.tseries.frequencies.to_offset(freq)  # type: ignore\n            assert not isinstance(start, (int, float))\n            assert not isinstance(end, (int, float))\n        else:\n            assert isinstance(freq, (int, float))\n            out_dict.freq = freq\n\n        if start is not None:\n            if is_date:\n                start = pd.to_datetime(start)\n        else:\n            start = self._obj.agg(F.min(ts_column).alias(\"__min__\")).toPandas()[\n                \"__min__\"\n            ][0]\n\n        if end is not None:\n            if is_date:\n                end = pd.to_datetime(end)\n        else:\n            end = self._obj.agg(F.max(ts_column).alias(\"__max__\")).toPandas()[\n                \"__max__\"\n            ][0]\n\n        if is_date:\n            complete_time_series = pd.period_range(\n                start=start, end=end, freq=out_dict.freq\n            ).to_timestamp()  # type: ignore\n        else:\n            # note that `end` should be inclusive whereas range is top-exclusive\n            complete_time_series = np.arange(start, end + freq, out_dict.freq)\n\n        data = self._obj\n        if is_date:\n            data = data.withColumn('__offsets_since_epoch__', offsets_since_epoch(freq)(ts_column))\n\n        is_date = _is_date(self._obj, ts_column)\n        out_dict.complete_time_series = complete_time_series\n        out_dict.data = data\n        out_dict.start, out_dict.end = start, end\n        out_dict.is_date = is_date\n        out_dict.panel_column_name = panel_column\n        out_dict.ts_column_name = ts_column\n        return out_dict\n\n    def tsfill(\n        self,\n        *,\n        fill_value: Any = None,\n        sentinel: str | None = None,\n        opts_replacement: SparkOpts | dict | None = None,\n    ) -&gt; pyspark.sql.dataframe.DataFrame:\n        \"\"\"\n        Fill in holes in time-series or panel data\n\n        Args:\n            fill_value: Value to fill in NAs generated by `tsfill`\n            sentinel: If not None, the name of a column indicating if a row was\n                present in the original data (True) or was filled in by `tsfill`\n                (False)\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing TimeOpts arguments from `ts()`\n\n\n        Returns:\n            Pyspark DataFrame\n\n        Note:\n            `tsfill` may shuffle the order of columns and rows in the data.\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from pyspark.sql import SparkSession\n            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n            &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... ))\n            &gt;&gt;&gt; cookies.toPandas()\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n            &gt;&gt;&gt; cookies_full.toPandas()\n               year        favorite     n\n            0  1999             NaN  &lt;NA&gt;\n            1  2000  Chocolate Chip    10\n            2  2001  Chocolate Chip    20\n            3  2002  Oatmeal Raisin    15\n            4  2003           Sugar    12\n            5  2004             NaN  &lt;NA&gt;\n            6  2005             NaN  &lt;NA&gt;\n            7  2006             NaN  &lt;NA&gt;\n            8  2007             NaN  &lt;NA&gt;\n            9  2008             M&amp;M    40\n\n        \"\"\"\n        spark = SparkSession.builder.getOrCreate()\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        is_panel = SparkOpts._extract_opt(ts_args, \"panel_column\") is not None\n        ts = self.tsset(ts_args=ts_args)\n        assert ts.data is not None\n        full = spark.createDataFrame(\n            pd.DataFrame({ts.ts_column_name: ts.complete_time_series})\n        )\n        dta = ts.data\n        if sentinel is None and fill_value is not None:\n            sentinel = \"__sentinel_dropped__\"\n        if sentinel is not None:\n            dta = dta.withColumn(sentinel, F.lit(True))\n        if not is_panel:\n            out = full.join(dta, ts.ts_column_name, \"left\")\n        else:\n            ids = ts.data.select(ts.panel_column_name).distinct()\n            full = full.crossJoin(ids)\n            out = full.join(dta, [ts.ts_column_name, ts.panel_column_name], \"left\")\n        if sentinel is not None:\n            out = out.withColumn(sentinel, F.coalesce(F.col(sentinel), F.lit(False)))\n            if fill_value is not None:\n                # we can't use fillna here since it doesn't admit a predicate.\n                # instead, use `sentinel` as predicate and fill in only rows for which sentinel=TRUE.\n                xt_cols = [ts.ts_column_name,ts.panel_column_name] if is_panel else [ts.ts_column_name]\n                other_cols = [col for col in out.columns if col not in xt_cols]\n                exprs = [F.expr(f\"CASE WHEN {sentinel} THEN {fill_value} ELSE {col} END\") for col in other_cols]\n                out = out.select(xt_cols, exprs)\n        return out.drop(\"__sentinel_dropped__\", \"__offsets_since_epoch__\")\n\n    def with_lag(\n        self,\n        col_name: str,\n        column: str,\n        back: int = 1,\n        *,\n        opts_replacement: SparkOpts | dict | None = None,\n    ) -&gt; pyspark.sql.dataframe.DataFrame:\n        \"\"\"\n        Add a lag column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the lag column\n            column: Column to take the lag of\n            back: How many records to go back. Negative values are \"leads\"\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing PandasOpts arguments from `ts()`\n\n        Returns:\n            Pandas DataFrame\n\n        Note:\n            `with_lag` may shuffle the order of columns and rows in the data.\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from pyspark.sql import SparkSession\n            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n            &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... ))\n            &gt;&gt;&gt; cookies.toPandas()\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n            &gt;&gt;&gt; cookies_lag.toPandas()\n               year        favorite   n previous_favorite\n            0  2000  Chocolate Chip  10               NaN\n            1  2001  Chocolate Chip  20    Chocolate Chip\n            2  2002  Oatmeal Raisin  15    Chocolate Chip\n            3  2003           Sugar  12    Oatmeal Raisin\n            4  2008             M&amp;M  40               NaN\n\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        is_panel = SparkOpts._extract_opt(ts_args, \"panel_column\") is not None\n        ts = self.tsset(ts_args=ts_args)\n        assert ts.data is not None\n        if not ts.is_date:\n            # in this case, we just order by ts.ts_column_name\n            # and use ts.freq as the rangeSpec\n            dta = ts.data\n            order_column = ts.ts_column_name\n            offset = ts.freq\n            range_spec = (-1 * back * offset, -1 * back * offset)\n        else:\n            # in this case, we order by the numeric value of ts.ts_column\n            # and use ts.freq.n as the rangeSpec\n            dta = ts.data\n            order_column = \"__offsets_since_epoch__\"\n            offset = ts.freq.n\n            range_spec = (-1 * back * offset, -1 * back * offset)\n\n        if not is_panel:\n            return dta.withColumn(\n                    col_name,\n                    F.max(column).over(\n                        Window.orderBy(order_column).rangeBetween(\n                            *range_spec\n                        )\n                    ),\n            ).drop(\"__offsets_since_epoch__\")\n        else:\n            return dta.withColumn(\n                    col_name,\n                    F.max(column).over(\n                        Window.partitionBy(ts.panel_column_name)\n                        .orderBy(order_column)\n                        .rangeBetween(*range_spec)\n                    ),\n            ).drop(\"__offsets_since_epoch__\")\n\n\n    def with_lead(\n            self,\n            col_name: str,\n            column: str,\n            forward: int | None = 1,\n            opts_replacement: SparkOpts | dict | None = None,\n        ) -&gt; pyspark.sql.dataframe.DataFrame:\n            \"\"\"\n            Add a lead column to a PySpark DataFrame\n\n            Args:\n                col_name: What to name the lead column\n                column: Column to take the lead of\n                forward: How many records to go forward. Negative values are \"lags\"\n                opts_replacement: Replace Arguments for the time-series structure of the data.\n                    Defaults to the existing SparkOpts arguments from `ts()`\n\n            Returns:\n                PySpark DataFrame\n\n            Note:\n                `with_lag` may shuffle the order of columns and rows in the data.\n\n            Examples:\n                &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n                &gt;&gt;&gt; import pandas as pd\n                &gt;&gt;&gt; from pyspark.sql import SparkSession\n                &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n                &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n                ...   {\n                ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n                ...        \"favorite\": [\n                ...         \"Chocolate Chip\",\n                ...         \"Chocolate Chip\",\n                ...         \"Oatmeal Raisin\",\n                ...         \"Sugar\",\n                ...         \"M&amp;M\",\n                ...    ],\n                ...    \"n\": [10, 20, 15, 12, 40],\n                ...   }\n                ... ))\n                &gt;&gt;&gt; cookies.toPandas()\n                year        favorite   n\n                0  2000  Chocolate Chip  10\n                1  2001  Chocolate Chip  20\n                2  2002  Oatmeal Raisin  15\n                3  2003           Sugar  12\n                4  2008             M&amp;M  40\n                &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n                &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n                &gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n                &gt;&gt;&gt; cookies_lead.toPandas()\n                year        favorite   n   next_favorite\n                0  2000  Chocolate Chip  10  Chocolate Chip\n                1  2001  Chocolate Chip  20  Oatmeal Raisin\n                2  2002  Oatmeal Raisin  15           Sugar\n                3  2003           Sugar  12             NaN\n                4  2008             M&amp;M  40             NaN\n            \"\"\"\n            if opts_replacement is not None:\n                ts_args = opts_replacement\n            else:\n                ts_args = self._opts\n            return self.with_lag(\n                col_name, column, back=-1 * forward, opts_replacement=ts_args\n            ).drop(\"__offsets_since_epoch__\")\n\n    def with_difference(\n        self,\n        col_name: str,\n        column: str,\n        back: int | None = 1,\n        *,\n        opts_replacement: SparkOpts | dict | None = None,\n    ) -&gt; pyspark.sql.dataframe.DataFrame:\n        \"\"\"\n        Add a difference column to a Pandas DataFrame\n\n        Args:\n            col_name: What to name the difference column\n            column: Column to take the difference of\n            back: How many records to go back to compute difference.\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing PandasOpts arguments from `ts()`\n\n        Returns:\n            PySpark DataFrame\n\n        Note:\n            `with_lag` may shuffle the order of columns and rows in the data.\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from pyspark.sql import SparkSession\n            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n            &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... ))\n            &gt;&gt;&gt; cookies.toPandas()\n               year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n            &gt;&gt;&gt; cookies_diff.toPandas()\n               year        favorite   n  change_in_panelists\n            0  2000  Chocolate Chip  10                  NaN\n            1  2001  Chocolate Chip  20                 10.0\n            2  2002  Oatmeal Raisin  15                 -5.0\n            3  2003           Sugar  12                 -3.0\n            4  2008             M&amp;M  40                  NaN\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        lag = self.with_lag(\n            \"__difference_dummy__\", column, back, opts_replacement=ts_args\n        )\n        out = lag.withColumn(col_name, F.col(column) - F.col(\"__difference_dummy__\")).drop(\"__difference_dummy__\")\n        return out.drop(\"__offsets_since_epoch__\")\n</code></pre>"},{"location":"api/pyspark/#tslib.pyspark_api.TSAccessor.tsfill","title":"<code>tsfill(*, fill_value=None, sentinel=None, opts_replacement=None)</code>","text":"<p>Fill in holes in time-series or panel data</p> <p>Parameters:</p> Name Type Description Default <code>fill_value</code> <code>Any</code> <p>Value to fill in NAs generated by <code>tsfill</code></p> <code>None</code> <code>sentinel</code> <code>str | None</code> <p>If not None, the name of a column indicating if a row was present in the original data (True) or was filled in by <code>tsfill</code> (False)</p> <code>None</code> <code>opts_replacement</code> <code>SparkOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing TimeOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pyspark DataFrame</p> Note <p><code>tsfill</code> may shuffle the order of columns and rows in the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyspark.sql import SparkSession\n&gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n&gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... ))\n&gt;&gt;&gt; cookies.toPandas()\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n&gt;&gt;&gt; cookies_full.toPandas()\n   year        favorite     n\n0  1999             NaN  &lt;NA&gt;\n1  2000  Chocolate Chip    10\n2  2001  Chocolate Chip    20\n3  2002  Oatmeal Raisin    15\n4  2003           Sugar    12\n5  2004             NaN  &lt;NA&gt;\n6  2005             NaN  &lt;NA&gt;\n7  2006             NaN  &lt;NA&gt;\n8  2007             NaN  &lt;NA&gt;\n9  2008             M&amp;M    40\n</code></pre> Source code in <code>tslib/pyspark_api.py</code> <pre><code>def tsfill(\n    self,\n    *,\n    fill_value: Any = None,\n    sentinel: str | None = None,\n    opts_replacement: SparkOpts | dict | None = None,\n) -&gt; pyspark.sql.dataframe.DataFrame:\n    \"\"\"\n    Fill in holes in time-series or panel data\n\n    Args:\n        fill_value: Value to fill in NAs generated by `tsfill`\n        sentinel: If not None, the name of a column indicating if a row was\n            present in the original data (True) or was filled in by `tsfill`\n            (False)\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing TimeOpts arguments from `ts()`\n\n\n    Returns:\n        Pyspark DataFrame\n\n    Note:\n        `tsfill` may shuffle the order of columns and rows in the data.\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyspark.sql import SparkSession\n        &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n        &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... ))\n        &gt;&gt;&gt; cookies.toPandas()\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_full = cookies_ts.tsfill()\n        &gt;&gt;&gt; cookies_full.toPandas()\n           year        favorite     n\n        0  1999             NaN  &lt;NA&gt;\n        1  2000  Chocolate Chip    10\n        2  2001  Chocolate Chip    20\n        3  2002  Oatmeal Raisin    15\n        4  2003           Sugar    12\n        5  2004             NaN  &lt;NA&gt;\n        6  2005             NaN  &lt;NA&gt;\n        7  2006             NaN  &lt;NA&gt;\n        8  2007             NaN  &lt;NA&gt;\n        9  2008             M&amp;M    40\n\n    \"\"\"\n    spark = SparkSession.builder.getOrCreate()\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    is_panel = SparkOpts._extract_opt(ts_args, \"panel_column\") is not None\n    ts = self.tsset(ts_args=ts_args)\n    assert ts.data is not None\n    full = spark.createDataFrame(\n        pd.DataFrame({ts.ts_column_name: ts.complete_time_series})\n    )\n    dta = ts.data\n    if sentinel is None and fill_value is not None:\n        sentinel = \"__sentinel_dropped__\"\n    if sentinel is not None:\n        dta = dta.withColumn(sentinel, F.lit(True))\n    if not is_panel:\n        out = full.join(dta, ts.ts_column_name, \"left\")\n    else:\n        ids = ts.data.select(ts.panel_column_name).distinct()\n        full = full.crossJoin(ids)\n        out = full.join(dta, [ts.ts_column_name, ts.panel_column_name], \"left\")\n    if sentinel is not None:\n        out = out.withColumn(sentinel, F.coalesce(F.col(sentinel), F.lit(False)))\n        if fill_value is not None:\n            # we can't use fillna here since it doesn't admit a predicate.\n            # instead, use `sentinel` as predicate and fill in only rows for which sentinel=TRUE.\n            xt_cols = [ts.ts_column_name,ts.panel_column_name] if is_panel else [ts.ts_column_name]\n            other_cols = [col for col in out.columns if col not in xt_cols]\n            exprs = [F.expr(f\"CASE WHEN {sentinel} THEN {fill_value} ELSE {col} END\") for col in other_cols]\n            out = out.select(xt_cols, exprs)\n    return out.drop(\"__sentinel_dropped__\", \"__offsets_since_epoch__\")\n</code></pre>"},{"location":"api/pyspark/#tslib.pyspark_api.TSAccessor.with_difference","title":"<code>with_difference(col_name, column, back=1, *, opts_replacement=None)</code>","text":"<p>Add a difference column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the difference column</p> required <code>column</code> <code>str</code> <p>Column to take the difference of</p> required <code>back</code> <code>int | None</code> <p>How many records to go back to compute difference.</p> <code>1</code> <code>opts_replacement</code> <code>SparkOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing PandasOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>PySpark DataFrame</p> Note <p><code>with_lag</code> may shuffle the order of columns and rows in the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyspark.sql import SparkSession\n&gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n&gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... ))\n&gt;&gt;&gt; cookies.toPandas()\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n&gt;&gt;&gt; cookies_diff.toPandas()\n   year        favorite   n  change_in_panelists\n0  2000  Chocolate Chip  10                  NaN\n1  2001  Chocolate Chip  20                 10.0\n2  2002  Oatmeal Raisin  15                 -5.0\n3  2003           Sugar  12                 -3.0\n4  2008             M&amp;M  40                  NaN\n</code></pre> Source code in <code>tslib/pyspark_api.py</code> <pre><code>def with_difference(\n    self,\n    col_name: str,\n    column: str,\n    back: int | None = 1,\n    *,\n    opts_replacement: SparkOpts | dict | None = None,\n) -&gt; pyspark.sql.dataframe.DataFrame:\n    \"\"\"\n    Add a difference column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the difference column\n        column: Column to take the difference of\n        back: How many records to go back to compute difference.\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing PandasOpts arguments from `ts()`\n\n    Returns:\n        PySpark DataFrame\n\n    Note:\n        `with_lag` may shuffle the order of columns and rows in the data.\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyspark.sql import SparkSession\n        &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n        &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... ))\n        &gt;&gt;&gt; cookies.toPandas()\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_diff = cookies_ts.with_difference(\"change_in_panelists\", column=\"n\")\n        &gt;&gt;&gt; cookies_diff.toPandas()\n           year        favorite   n  change_in_panelists\n        0  2000  Chocolate Chip  10                  NaN\n        1  2001  Chocolate Chip  20                 10.0\n        2  2002  Oatmeal Raisin  15                 -5.0\n        3  2003           Sugar  12                 -3.0\n        4  2008             M&amp;M  40                  NaN\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    lag = self.with_lag(\n        \"__difference_dummy__\", column, back, opts_replacement=ts_args\n    )\n    out = lag.withColumn(col_name, F.col(column) - F.col(\"__difference_dummy__\")).drop(\"__difference_dummy__\")\n    return out.drop(\"__offsets_since_epoch__\")\n</code></pre>"},{"location":"api/pyspark/#tslib.pyspark_api.TSAccessor.with_lag","title":"<code>with_lag(col_name, column, back=1, *, opts_replacement=None)</code>","text":"<p>Add a lag column to a Pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the lag column</p> required <code>column</code> <code>str</code> <p>Column to take the lag of</p> required <code>back</code> <code>int</code> <p>How many records to go back. Negative values are \"leads\"</p> <code>1</code> <code>opts_replacement</code> <code>SparkOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing PandasOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas DataFrame</p> Note <p><code>with_lag</code> may shuffle the order of columns and rows in the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyspark.sql import SparkSession\n&gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n&gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... ))\n&gt;&gt;&gt; cookies.toPandas()\n   year        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n&gt;&gt;&gt; cookies_lag.toPandas()\n   year        favorite   n previous_favorite\n0  2000  Chocolate Chip  10               NaN\n1  2001  Chocolate Chip  20    Chocolate Chip\n2  2002  Oatmeal Raisin  15    Chocolate Chip\n3  2003           Sugar  12    Oatmeal Raisin\n4  2008             M&amp;M  40               NaN\n</code></pre> Source code in <code>tslib/pyspark_api.py</code> <pre><code>def with_lag(\n    self,\n    col_name: str,\n    column: str,\n    back: int = 1,\n    *,\n    opts_replacement: SparkOpts | dict | None = None,\n) -&gt; pyspark.sql.dataframe.DataFrame:\n    \"\"\"\n    Add a lag column to a Pandas DataFrame\n\n    Args:\n        col_name: What to name the lag column\n        column: Column to take the lag of\n        back: How many records to go back. Negative values are \"leads\"\n        opts_replacement: Replace Arguments for the time-series structure of the data.\n            Defaults to the existing PandasOpts arguments from `ts()`\n\n    Returns:\n        Pandas DataFrame\n\n    Note:\n        `with_lag` may shuffle the order of columns and rows in the data.\n\n    Examples:\n        &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from pyspark.sql import SparkSession\n        &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n        &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n        ...   {\n        ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n        ...        \"favorite\": [\n        ...         \"Chocolate Chip\",\n        ...         \"Chocolate Chip\",\n        ...         \"Oatmeal Raisin\",\n        ...         \"Sugar\",\n        ...         \"M&amp;M\",\n        ...    ],\n        ...    \"n\": [10, 20, 15, 12, 40],\n        ...   }\n        ... ))\n        &gt;&gt;&gt; cookies.toPandas()\n           year        favorite   n\n        0  2000  Chocolate Chip  10\n        1  2001  Chocolate Chip  20\n        2  2002  Oatmeal Raisin  15\n        3  2003           Sugar  12\n        4  2008             M&amp;M  40\n        &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n        &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n        &gt;&gt;&gt; cookies_lag = cookies_ts.with_lag(\"previous_favorite\", column=\"favorite\")\n        &gt;&gt;&gt; cookies_lag.toPandas()\n           year        favorite   n previous_favorite\n        0  2000  Chocolate Chip  10               NaN\n        1  2001  Chocolate Chip  20    Chocolate Chip\n        2  2002  Oatmeal Raisin  15    Chocolate Chip\n        3  2003           Sugar  12    Oatmeal Raisin\n        4  2008             M&amp;M  40               NaN\n\n    \"\"\"\n    if opts_replacement is not None:\n        ts_args = opts_replacement\n    else:\n        ts_args = self._opts\n    is_panel = SparkOpts._extract_opt(ts_args, \"panel_column\") is not None\n    ts = self.tsset(ts_args=ts_args)\n    assert ts.data is not None\n    if not ts.is_date:\n        # in this case, we just order by ts.ts_column_name\n        # and use ts.freq as the rangeSpec\n        dta = ts.data\n        order_column = ts.ts_column_name\n        offset = ts.freq\n        range_spec = (-1 * back * offset, -1 * back * offset)\n    else:\n        # in this case, we order by the numeric value of ts.ts_column\n        # and use ts.freq.n as the rangeSpec\n        dta = ts.data\n        order_column = \"__offsets_since_epoch__\"\n        offset = ts.freq.n\n        range_spec = (-1 * back * offset, -1 * back * offset)\n\n    if not is_panel:\n        return dta.withColumn(\n                col_name,\n                F.max(column).over(\n                    Window.orderBy(order_column).rangeBetween(\n                        *range_spec\n                    )\n                ),\n        ).drop(\"__offsets_since_epoch__\")\n    else:\n        return dta.withColumn(\n                col_name,\n                F.max(column).over(\n                    Window.partitionBy(ts.panel_column_name)\n                    .orderBy(order_column)\n                    .rangeBetween(*range_spec)\n                ),\n        ).drop(\"__offsets_since_epoch__\")\n</code></pre>"},{"location":"api/pyspark/#tslib.pyspark_api.TSAccessor.with_lead","title":"<code>with_lead(col_name, column, forward=1, opts_replacement=None)</code>","text":"<p>Add a lead column to a PySpark DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>What to name the lead column</p> required <code>column</code> <code>str</code> <p>Column to take the lead of</p> required <code>forward</code> <code>int | None</code> <p>How many records to go forward. Negative values are \"lags\"</p> <code>1</code> <code>opts_replacement</code> <code>SparkOpts | dict | None</code> <p>Replace Arguments for the time-series structure of the data. Defaults to the existing SparkOpts arguments from <code>ts()</code></p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>PySpark DataFrame</p> Note <p><code>with_lag</code> may shuffle the order of columns and rows in the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pyspark.sql import SparkSession\n&gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n&gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n...   {\n...        \"year\": [2000, 2001, 2002, 2003, 2008],\n...        \"favorite\": [\n...         \"Chocolate Chip\",\n...         \"Chocolate Chip\",\n...         \"Oatmeal Raisin\",\n...         \"Sugar\",\n...         \"M&amp;M\",\n...    ],\n...    \"n\": [10, 20, 15, 12, 40],\n...   }\n... ))\n&gt;&gt;&gt; cookies.toPandas()\nyear        favorite   n\n0  2000  Chocolate Chip  10\n1  2001  Chocolate Chip  20\n2  2002  Oatmeal Raisin  15\n3  2003           Sugar  12\n4  2008             M&amp;M  40\n&gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n&gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n&gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n&gt;&gt;&gt; cookies_lead.toPandas()\nyear        favorite   n   next_favorite\n0  2000  Chocolate Chip  10  Chocolate Chip\n1  2001  Chocolate Chip  20  Oatmeal Raisin\n2  2002  Oatmeal Raisin  15           Sugar\n3  2003           Sugar  12             NaN\n4  2008             M&amp;M  40             NaN\n</code></pre> Source code in <code>tslib/pyspark_api.py</code> <pre><code>def with_lead(\n        self,\n        col_name: str,\n        column: str,\n        forward: int | None = 1,\n        opts_replacement: SparkOpts | dict | None = None,\n    ) -&gt; pyspark.sql.dataframe.DataFrame:\n        \"\"\"\n        Add a lead column to a PySpark DataFrame\n\n        Args:\n            col_name: What to name the lead column\n            column: Column to take the lead of\n            forward: How many records to go forward. Negative values are \"lags\"\n            opts_replacement: Replace Arguments for the time-series structure of the data.\n                Defaults to the existing SparkOpts arguments from `ts()`\n\n        Returns:\n            PySpark DataFrame\n\n        Note:\n            `with_lag` may shuffle the order of columns and rows in the data.\n\n        Examples:\n            &gt;&gt;&gt; from tslib.pyspark_api import SparkOpts\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; from pyspark.sql import SparkSession\n            &gt;&gt;&gt; spark = SparkSession.builder.getOrCreate()\n            &gt;&gt;&gt; cookies = spark.createDataFrame(pd.DataFrame(\n            ...   {\n            ...        \"year\": [2000, 2001, 2002, 2003, 2008],\n            ...        \"favorite\": [\n            ...         \"Chocolate Chip\",\n            ...         \"Chocolate Chip\",\n            ...         \"Oatmeal Raisin\",\n            ...         \"Sugar\",\n            ...         \"M&amp;M\",\n            ...    ],\n            ...    \"n\": [10, 20, 15, 12, 40],\n            ...   }\n            ... ))\n            &gt;&gt;&gt; cookies.toPandas()\n            year        favorite   n\n            0  2000  Chocolate Chip  10\n            1  2001  Chocolate Chip  20\n            2  2002  Oatmeal Raisin  15\n            3  2003           Sugar  12\n            4  2008             M&amp;M  40\n            &gt;&gt;&gt; cookies_args = SparkOpts(ts_column=\"year\", freq=1, start=1999)\n            &gt;&gt;&gt; cookies_ts = cookies.ts(cookies_args)\n            &gt;&gt;&gt; cookies_lead = cookies_ts.with_lead(\"next_favorite\", column=\"favorite\")\n            &gt;&gt;&gt; cookies_lead.toPandas()\n            year        favorite   n   next_favorite\n            0  2000  Chocolate Chip  10  Chocolate Chip\n            1  2001  Chocolate Chip  20  Oatmeal Raisin\n            2  2002  Oatmeal Raisin  15           Sugar\n            3  2003           Sugar  12             NaN\n            4  2008             M&amp;M  40             NaN\n        \"\"\"\n        if opts_replacement is not None:\n            ts_args = opts_replacement\n        else:\n            ts_args = self._opts\n        return self.with_lag(\n            col_name, column, back=-1 * forward, opts_replacement=ts_args\n        ).drop(\"__offsets_since_epoch__\")\n</code></pre>"}]}